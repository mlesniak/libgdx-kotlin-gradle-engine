package com.mlesniak.engine.engine

import com.mlesniak.engine.core.Canvas
import kotlin.math.PI
import kotlin.math.absoluteValue
import kotlin.math.cos
import kotlin.math.roundToInt
import kotlin.math.sin

// TODO(mlesniak) Use bytebuffer instead of single pixels which is even cooler

// The only function we need is to draw single pixels
// on a canvas. Everything else will be implemented
// by our own functions and algorithms.
//
// TODO?
// - we're mixing perspective functions and pure drawing functions; should
//   this be split up (pixel, circle, line and triangle are pure, model
//   is not).
@Suppress("MemberVisibilityCanBePrivate")
class Engine(private val canvas: Canvas) {
    var projectionMatrix: Matrix =
        BaseMatrix.scale(1.0f, 1.0f, 1.0f) *
            BaseMatrix.translate((canvas.width / 2).toFloat(), (canvas.height / 2).toFloat())

    fun height() = canvas.height
    fun width() = canvas.width

    fun pixel(p: Vector, rgb: Int = 0xFFFFFF) {
        canvas.pixel(p.x.toInt(), p.y.toInt(), rgb)
    }

    fun circle(x: Int, y: Int, r: Int, rgb: Int = 0xFFFFFF) {
        for (angle in 0..360) {
            val dx = cos(angle * PI / 180.0)
            val dy = sin(angle * PI / 180.0)

            pixel(Vector((x + dx * r).toInt(), (y + dy * r).toInt()), rgb)
        }
    }

    // Source: https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm
    fun line(p0: Vector, p1: Vector, rgb: Int = 0x555555) {
        val dx = (p0.x - p1.x).absoluteValue
        val sx = if (p0.x < p1.x) 1 else -1
        val dy = -(p1.y - p0.y).absoluteValue
        val sy = if (p0.y < p1.y) 1 else -1

        var x0 = p0.x.roundToInt()
        var y0 = p0.y.roundToInt()
        val p1x = p1.x.roundToInt()
        val p1y = p1.y.roundToInt()
        var error = dx + dy

        while (true) {
            pixel(Vector(x0, y0), rgb)
            if (x0 == p1x && y0 == p1y) {
                break
            }
            val e2 = 2 * error
            if (e2 >= dy) {
                if (x0 == p1x) {
                    break
                }
                error += dy
                x0 += sx
            }
            if (e2 <= dx) {
                if (y0 == p1y) {
                    break
                }
                error += dx
                y0 += sy
            }
        }
    }

    fun clear(rgb: Int = 0xCCCCCC) {
        canvas.clear(rgb)
    }

    // Explanation of the algorithm at http://www.sunshine2k.de/coding/java/TriangleRasterization/TriangleRasterization.html#algo2
    private fun fillBottomFlatTriangle(p0: Vector, p1: Vector, p2: Vector, rgb: Int) {
        val invslope1 = (p1.x - p0.x) / (p1.y - p0.y)
        val invslope2 = (p2.x - p0.x) / (p2.y - p0.y)
        var curx1 = p0.x
        var curx2 = p0.x

        for (y in p0.y.toInt() until p1.y.toInt()) {
            // line(Vector(curx1.toInt(), y), Vector(curx2.toInt(), y), rgb)
            line(Vector(curx1.toInt(), y), Vector(curx2.toInt(), y), 0xFF0000)
            curx1 += invslope1
            curx2 += invslope2
        }
    }

    private fun fillTopFlatTriangle(p0: Vector, p1: Vector, p2: Vector, rgb: Int) {
        val invslope1 = (p2.x - p0.x) / (p2.y - p0.y)
        val invslope2 = (p2.x - p1.x) / (p2.y - p1.y)
        var curx1 = p2.x
        var curx2 = p2.x

        for (y in p2.y.toInt() downTo p0.y.toInt()) {
            // line(Vector(curx1.toInt(), y), Vector(curx2.toInt(), y), rgb)
            line(Vector(curx1.toInt(), y), Vector(curx2.toInt(), y), 0x00FF00)
            curx1 -= invslope1
            curx2 -= invslope2
        }
    }

    fun triangle(p0_: Vector, p1_: Vector, p2_: Vector, rgb: Int = 0x555555) {
        // Idiomatic kotlin vs if-else statements for performance?
        // Compare generated bytecode and do some micro-benchmarks?
        val (p0, p1, p2) = listOf(p0_, p1_, p2_).sortedBy { it.y }

        if (p1.y == p2.y) {
            fillBottomFlatTriangle(p0, p1, p2, rgb)
        } else if (p0.y == p1.y) {
            fillTopFlatTriangle(p0, p1, p2, rgb)
        } else {
            // Vertice v4 = new Vertice(
            //       (int)(vt1.x + ((float)(vt2.y - vt1.y) / (float)(vt3.y - vt1.y)) * (vt3.x - vt1.x)), vt2.y);

            val middle = Vector(
                p0.x + ((p1.y - p0.y) / (p2.y - p0.y)) * (p2.x - p0.x),
                p1.y
            )
            fillBottomFlatTriangle(p0, p1, middle, rgb)
            fillTopFlatTriangle(p1, middle, p2, rgb)
        }
    }
}
